###当想稍后执行一段代码的时候
js中延迟执行一段代码很常见，
（执行到setTimeout()的时候发生了什么：把setTimeout里的函数推进一个队列，然后跳过接着执行下面的代码，当前执行环境结束后，检查异步队列，延迟时间是否到，到了执行，没到的话，执行其他的）
setTimeout()通常被用来实现这个需求。

同样的方法也可以用在angular中，但是必须把延迟执行的函数用$apply包起来，以加入脏检查。不过直接使用$timeout服务更方便；

但是在angular中还有一种方法可以延迟执行一段代码 —— $evalAsync；

$evalAsync 接受一个函数，然后加入队列，供以后调用，并且一定会在当前digest中调用；

$evalAsync优于$timeout的原因：
如果你用$timeout 0s延迟执行一个函数，你把何时执行这个函数的控制权交给了浏览器，浏览器事件循环的关系，它可能选择执行一些其他的代码，比如，渲染UI、执行点击回调、ajax回调，你不知道确切啥时候你延迟的函数会得到执行。
但是如果使用$evalAsync，控制权依然在angular手里，你能知道延迟函数更确切的执行时机。angular保证当前digest中调用这个延迟函数，在浏览器决定做其他事之前。

这个区别有何用处：可以避免不必要的渲染。你不会想数据频繁变化的时候也让浏览器去跟着频繁渲染。

#### $evalAsync和$applyAsync
$evalAsync和$applyAsync里传入的函数都会延迟执行，但是它们还是有区别，所以使用场景不同

先来看看这样一个场景：刚加载一个页面的时候有大量的http请求，每个异步到达的数据都可能引起scope数据变动，如果每个请求都执行一下脏检查，大量http请求又间隔很短（页面刚加载时通常如此），
会发生许多不必要的脏检查。你更希望的是这间隔很紧的几个http发生完后再进行脏检查

$applyAsync就是用来满足这个需求的。合并紧邻发生的多次数据变动，只运行一次脏检查。而$evalAsync不关心合并脏检查，只保证延迟的代码会在本次脏检查中执行，如果当前没有脏检查发生，那便启动一个。所以$evalAsync多用在watche 的 listener。









